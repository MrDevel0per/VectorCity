<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Pandemic: Vector City â€“ Complete Enhanced Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="description" content="Stylized 3D pandemic containment game with tutorial, difficulty selection, pause/settings, bloom & depth of field. Single file, CORS-safe."/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
/* =======================================================================
   CORE THEME / RESET
   ======================================================================= */
:root {
  --accent:#4dffd7;
  --accent2:#ffb347;
  --danger:#ff3d55;
  --good:#5dffa5;
  --warn:#ffb347;
  --bg:#08131e;
  --panel:#112233d0;
  --panel-strong:#17354dd0;
  --glass:blur(14px) saturate(210%);
  --font:'Poppins', system-ui, sans-serif;
  font-size:clamp(12px,1.45vh,18px);
}
*{box-sizing:border-box;}
html,body{margin:0;padding:0;background:var(--bg);color:#edf8fc;font-family:var(--font);overflow:hidden;}
.hidden{display:none !important;}
b{color:var(--accent);font-weight:600;}
em{color:var(--accent2);font-style:normal;font-weight:600;}
/* =======================================================================
   CANVAS
   ======================================================================= */
#game{position:fixed;inset:0;width:100%;height:100%;display:block;background:#000;outline:none;}
/* =======================================================================
   LOADING
   ======================================================================= */
#loadingScreen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:radial-gradient(circle at 50% 45%,#15324f 0%,#061019 70%);z-index:9999;overflow:hidden;}
#loadingScreen::after{content:"";position:absolute;inset:0;
  background:radial-gradient(circle at 78% 18%,rgba(97,222,255,.25),transparent 60%),
             radial-gradient(circle at 17% 82%,rgba(255,145,82,.23),transparent 65%),
             linear-gradient(120deg,rgba(255,255,255,.07),transparent);
  animation:overlayDrift 22s linear infinite;mix-blend-mode:overlay;pointer-events:none;}
@keyframes overlayDrift{0%{transform:translate(0,0) scale(1);}50%{transform:translate(-4%,-3%) scale(1.05);}100%{transform:translate(0,0) scale(1);}}
.logo{font-size:3.6rem;font-weight:800;letter-spacing:.16em;background:linear-gradient(90deg,#4dffd7,#6ac8ff,#ffb347,#4dffd7);
  -webkit-background-clip:text;color:transparent;filter:drop-shadow(0 0 18px #4dffd788) drop-shadow(0 0 42px #00ffe055);
  animation:floatLogo 5s ease-in-out infinite;text-align:center;}
@keyframes floatLogo{0%,100%{transform:translateY(0);}50%{transform:translateY(-12px);}}
.barOuter{width:420px;max-width:80vw;height:18px;padding:3px;background:linear-gradient(120deg,#0d2434,#173b52);
  border:1px solid #204b63;border-radius:40px;position:relative;overflow:hidden;box-shadow:0 0 0 1px #173041,0 0 30px #4dffd755 inset,0 0 20px #112433;}
.barInner{position:absolute;top:3px;left:3px;bottom:3px;width:0%;background:linear-gradient(100deg,#4dffd7,#5cc9ff,#ffb347,#4dffd7);
  background-size:300% 100%;border-radius:30px;filter:brightness(1.1) saturate(1.25) drop-shadow(0 0 6px #4dffd755);animation:barShift 6s linear infinite;}
@keyframes barShift{0%{background-position:0 0;}100%{background-position:300% 0;}}
.hint{font-size:.95rem;max-width:620px;text-align:center;opacity:.85;}
.small{font-size:.65rem;opacity:.6;letter-spacing:.05em;}
.fadeOut{animation:fadeAway .7s ease forwards;}
@keyframes fadeAway{to{opacity:0;transform:translateY(10px);filter:blur(6px);}}

/* =======================================================================
   START MENU / DIFFICULTY
   ======================================================================= */
#startMenu{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:linear-gradient(135deg,#05121b 0%,#0f2535 90%);z-index:9000;}
.menuBox{background:linear-gradient(155deg,#142f44ee,#0d1f2dec 60%);padding:2rem 2.3rem 2.4rem;border:1px solid #20506a;
  border-radius:34px;display:flex;flex-direction:column;width:min(880px,92vw);gap:1.4rem;
  box-shadow:0 0 0 1px #193847,0 18px 44px -22px #000,0 0 90px -32px #4dffd7aa;backdrop-filter:blur(24px) saturate(240%);}
.menuBox h1{margin:0;font-size:2.2rem;letter-spacing:.14em;font-weight:700;
  background:linear-gradient(90deg,#4dffd7,#6ac8ff,#ffb347);-webkit-background-clip:text;color:transparent;
  filter:drop-shadow(0 0 14px #4dffd766);text-align:center;}
.menuSubtitle{text-align:center;font-size:.9rem;opacity:.85;line-height:1.5;margin-bottom:.2rem;}
.difficultyGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(165px,1fr));gap:1.05rem;}
.diffCard{border:1px solid #1f475a;background:linear-gradient(145deg,#15364a,#102532);padding:1rem .9rem 1rem;border-radius:22px;
  cursor:pointer;display:flex;flex-direction:column;gap:.55rem;min-height:160px;transition:transform .35s,box-shadow .45s,border-color .45s;}
.diffCard:hover{transform:translateY(-6px);border-color:#4dffd7;box-shadow:0 0 0 1px #3ddfc0,0 12px 30px -18px #000,0 0 50px -16px #4dffd777;}
.diffCard.selected{border-color:#4dffd7;box-shadow:0 0 0 1px #3ddfc0,0 0 26px -6px #4dffd799;}
.diffTitle{font-weight:600;letter-spacing:.08em;font-size:.78rem;display:flex;justify-content:space-between;align-items:center;color:#d9f9ff;}
.diffTitle span.badge{background:#4dffd7;color:#083238;font-weight:700;padding:.25rem .65rem;font-size:.55rem;border-radius:30px;letter-spacing:.1em;box-shadow:0 0 0 1px #92ffe9 inset;}
.diffDesc{font-size:.62rem;line-height:1.35;opacity:.85;}
#startButton{align-self:center;background:linear-gradient(120deg,#4dffd7,#6ac8ff,#4dffd7);color:#063033;font-weight:700;letter-spacing:.18em;
  border:none;padding:1.05rem 2.9rem 1.1rem;font-size:.82rem;border-radius:42px;cursor:pointer;
  box-shadow:0 16px 40px -22px #000,0 0 0 1px #44d9c0,0 0 80px -20px #4dffd7aa;transition:transform .45s,box-shadow .55s;}
#startButton:hover:not([disabled]){transform:translateY(-6px);box-shadow:0 22px 58px -28px #000,0 0 0 1px #4dffd7,0 0 110px -28px #4dffd7cc;}
#startButton[disabled]{filter:grayscale(.65);opacity:.45;cursor:not-allowed;}
#startButton:active:not([disabled]){transform:translateY(-2px) scale(.97);}

/* =======================================================================
   HUD
   ======================================================================= */
#ui{position:fixed;inset:0;pointer-events:none;font-size:.8rem;text-shadow:0 0 3px #000;z-index:200;}
.panel{background:var(--panel);backdrop-filter:var(--glass);padding:.65rem .95rem;border:1px solid #23455f;border-radius:18px;
  display:flex;gap:.6rem;align-items:center;position:relative;}
.panel::before{content:"";position:absolute;inset:0;border-radius:inherit;background:linear-gradient(145deg,rgba(255,255,255,.07),transparent 60%);
  mix-blend-mode:overlay;pointer-events:none;}
.panel.solid{background:var(--panel-strong);}
#hudTop{position:fixed;top:.75rem;left:.95rem;right:.95rem;display:grid;grid-template-columns:1fr 1fr;gap:.75rem;}
@media (max-width:1050px){#hudTop{grid-template-columns:1fr;}}
#hudBottom{position:fixed;bottom:.75rem;left:.95rem;right:.95rem;display:flex;flex-direction:column;gap:.6rem;}
.controls{font-size:.66rem;letter-spacing:.05em;opacity:.9;flex-wrap:wrap;}
#crosshair{width:20px;height:20px;position:absolute;top:50%;left:50%;translate:-50% -50%;border:2px solid var(--accent);border-radius:50%;
  box-shadow:0 0 10px #4dffd7aa inset,0 0 10px #4dffd7aa;filter:drop-shadow(0 0 8px #4dffd788);opacity:.85;}
/* Story Modal */
#storyBox{position:absolute;top:18%;left:50%;translate:-50% 0;max-width:660px;padding:1.4rem 1.75rem 1.5rem;
  background:linear-gradient(165deg,#122c43f2,#0b1c2df2 55%,#10283bf2);border:1px solid #1f4f66;border-radius:26px;
  box-shadow:0 0 44px -10px #4dffd777,0 0 0 1px #1a3748;line-height:1.5;font-size:.94rem;z-index:500;
  animation:fadeInModal .5s ease;}
@keyframes fadeInModal{from{opacity:0;transform:translate(-50%,-12px);}to{opacity:1;transform:translate(-50%,0);}}
.storyCloseBtn{margin-top:1rem;background:#173b4f;border:1px solid #2a5e74;color:#e8fcff;font-size:.65rem;padding:.65rem 1.3rem;
  letter-spacing:.14em;border-radius:14px;cursor:pointer;font-weight:600;transition:.35s;}
.storyCloseBtn:hover{background:#21556e;}
/* Event Log */
#eventLog{max-height:160px;overflow:hidden;flex-direction:column;font-size:.66rem;line-height:1.2;}
.logLine{padding:.25rem 0 .3rem;border-bottom:1px solid #1a3443;position:relative;animation:logIn .45s ease;}
@keyframes logIn{from{opacity:0;transform:translateY(6px);}to{opacity:1;transform:translateY(0);}}
.logLine::before{content:"";position:absolute;left:-6px;top:7px;width:4px;height:4px;border-radius:50%;background:#4dffd7;box-shadow:0 0 6px #4dffd7aa;}
.logLine.good::before{background:#5dffa5;box-shadow:0 0 6px #5dffa5aa;}
.logLine.warn::before{background:#ffb347;box-shadow:0 0 6px #ffb347aa;}
.logLine.infect::before{background:#ff3d55;box-shadow:0 0 6px #ff3d55aa;}
/* Radar */
#radar{position:fixed;right:1rem;bottom:11.5rem;width:200px;height:200px;border-radius:30px;background:linear-gradient(145deg,#132b3b,#0c1b28);
  border:1px solid #1d3d52;box-shadow:0 0 0 1px #1c394a,0 10px 24px -12px #000,0 0 30px -10px #4dffd766 inset;overflow:hidden;backdrop-filter:blur(10px) saturate(160%);z-index:210;}
#radar canvas{width:100%;height:100%;display:block;}
/* Tutorial Panel */
#tasksPanel{position:fixed;left:1rem;top:50%;translate:0 -50%;width:280px;max-width:68vw;
  background:linear-gradient(160deg,#142d42cc,#102436e8 60%);border:1px solid #1f495d;border-radius:22px;
  padding:1.1rem 1.2rem 1.25rem;display:flex;flex-direction:column;gap:.75rem;
  box-shadow:0 0 0 1px #1c3747,0 0 50px -12px #4dffd755,0 8px 28px -8px #000;pointer-events:auto;
  font-size:.7rem;backdrop-filter:blur(16px) saturate(210%);z-index:220;}
#tasksPanel h3{margin:0;font-size:.95rem;letter-spacing:.06em;font-weight:600;
  background:linear-gradient(90deg,#4dffd7,#ffb347);-webkit-background-clip:text;color:transparent;filter:drop-shadow(0 0 8px #4dffd788);}
.taskItem{display:flex;gap:.6rem;align-items:flex-start;position:relative;padding:.55rem .65rem .6rem;border-radius:14px;
  background:linear-gradient(130deg,#102536,#0d1d2c);border:1px solid #1f4153;line-height:1.25;
  box-shadow:0 0 0 1px #173442 inset;}
.taskItem.current{border-color:#4dffd7;box-shadow:0 0 0 1px #3ddfc0,0 0 16px -4px #4dffd788;background:linear-gradient(130deg,#103645,#0c1e2e);}
.taskItem.done{background:linear-gradient(130deg,#12392b,#112a24);border-color:#2c7c5c;}
.taskCheck{width:20px;height:20px;border-radius:8px;background:#143039;border:1px solid #2a5e74;display:flex;align-items:center;justify-content:center;font-size:.65rem;color:#4dffd7;font-weight:600;box-shadow:0 0 0 1px #285063 inset;}
.taskItem.done .taskCheck{background:#1c5c40;color:#5dffa5;border-color:#3f966f;box-shadow:0 0 0 1px #3f966f inset,0 0 10px #5dffa5aa;}
/* Help */
#helpToggleBtn{position:fixed;left:1rem;bottom:11rem;background:linear-gradient(145deg,#11384a,#0f2834);
  color:#dbfafd;padding:.75rem 1.1rem;font-size:.72rem;border:1px solid #256d85;border-radius:18px;cursor:pointer;z-index:220;pointer-events:auto;font-weight:600;}
#helpToggleBtn:hover{background:linear-gradient(145deg,#164557,#123443);}
#helpPanel{position:fixed;right:1.1rem;top:50%;translate:0 -50%;width:360px;max-width:80vw;
  background:linear-gradient(155deg,#143149f2,#0d1e2df2 60%);border:1px solid #20506a;border-radius:26px;
  padding:1.3rem 1.4rem 1.55rem;box-shadow:0 0 0 1px #1b3e51,0 12px 30px -12px #000,0 0 70px -30px #4dffd7aa;
  font-size:.72rem;line-height:1.45;pointer-events:auto;backdrop-filter:blur(22px) saturate(250%);
  display:flex;flex-direction:column;gap:.9rem;max-height:80vh;overflow:auto;z-index:220;}
#helpPanel h3{margin:0;font-size:1.05rem;letter-spacing:.07em;font-weight:600;
  background:linear-gradient(90deg,#4dffd7,#6ac8ff,#ffb347);-webkit-background-clip:text;color:transparent;filter:drop-shadow(0 0 8px #4dffd777);}
.helpGrid{display:grid;grid-template-columns:auto 1fr;gap:.45rem .95rem;}
kbd{background:#17394d;padding:.33rem .65rem .36rem;border-radius:10px;font-size:.66rem;letter-spacing:.05em;font-weight:600;
  box-shadow:0 0 0 1px #255b6f inset,0 2px 4px -2px #000;color:#d2faff;min-width:2.3ch;text-align:center;}
.btnClose{align-self:flex-end;background:#17394d;border:1px solid #2a6177;color:#ebfeff;padding:.62rem 1.2rem;font-size:.66rem;letter-spacing:.1em;border-radius:12px;font-weight:600;cursor:pointer;}
.btnClose:hover{background:#1d4760;}
/* Toast */
#toast{position:fixed;top:calc(50% + 200px);left:50%;translate:-50% 0;background:linear-gradient(125deg,#14485f,#0f374d);
  padding:.95rem 1.5rem 1.05rem;border:1px solid #24768e;border-radius:22px;font-size:.82rem;letter-spacing:.04em;
  box-shadow:0 14px 30px -16px #000,0 0 0 1px #1d5669,0 0 40px -12px #4dffd777;pointer-events:none;opacity:0;
  transform:translate(-50%,16px);transition:opacity .55s,transform .55s;max-width:520px;text-align:center;z-index:350;}
#toast.visible{opacity:1;transform:translate(-50%,0);}
/* Tutorial pulse */
#tutorialPulse{position:fixed;left:50%;top:50%;width:260px;height:260px;translate:-50% -50%;border-radius:50%;
  background:radial-gradient(circle,#4dffd733,#4dffd700 65%);animation:pulse 2.8s ease-in-out infinite;pointer-events:none;mix-blend-mode:screen;opacity:.55;z-index:230;}
@keyframes pulse{0%,100%{transform:translate(-50%,-50%) scale(.8);opacity:.35;}50%{transform:translate(-50%,-50%) scale(1.25);opacity:.65;}}
/* Pause / Settings */
#pauseMenu{position:fixed;inset:0;background:#06111bd8;backdrop-filter:blur(14px);display:flex;align-items:center;justify-content:center;z-index:600;}
.pausePanel{width:min(760px,90vw);max-height:86vh;overflow:auto;background:linear-gradient(150deg,#142f44,#0d1d2c 60%);
  border:1px solid #1e475d;border-radius:32px;padding:1.9rem 2.2rem 2.4rem;display:flex;flex-direction:column;gap:1.4rem;
  box-shadow:0 0 0 1px #1a3645,0 18px 42px -22px #000,0 0 90px -30px #4dffd7aa;}
.pausePanel h2{margin:0;font-size:1.6rem;letter-spacing:.12em;font-weight:700;
  background:linear-gradient(90deg,#4dffd7,#6ac8ff,#ffb347);-webkit-background-clip:text;color:transparent;}
.settingRow{display:grid;grid-template-columns:170px 1fr;gap:.7rem 1.1rem;align-items:center;font-size:.7rem;}
.settingRow label{font-weight:600;letter-spacing:.06em;opacity:.85;}
.settingRow input[type=range]{width:100%;}
.rangeVal{font-family:monospace;font-size:.66rem;padding:.22rem .55rem;background:#17394d;border:1px solid #2a5e74;border-radius:6px;}
.bigBtn{background:linear-gradient(145deg,#11384a,#0f2834);color:#defcff;border:1px solid #29657d;
  font-size:.7rem;letter-spacing:.14em;font-weight:600;padding:.75rem 1.35rem;border-radius:20px;cursor:pointer;
  box-shadow:0 4px 18px -10px #000,0 0 0 1px #1a3f4d,0 0 26px -8px #4dffd755;transition:background .4s,transform .45s;}
.bigBtn:hover{background:linear-gradient(145deg,#1a4a5e,#143d4e);transform:translateY(-3px);}
.bigBtn.danger{border-color:#7a2233;background:linear-gradient(145deg,#5a1823,#3a0e15);color:#ffdbe0;}
.bigBtn.danger:hover{background:linear-gradient(145deg,#761f2d,#4d141d);}
/* Scrollbars */
#helpPanel::-webkit-scrollbar,#pauseMenu::-webkit-scrollbar{width:10px;}
#helpPanel::-webkit-scrollbar-track,#pauseMenu::-webkit-scrollbar-track{background:#112532;border-radius:10px;}
#helpPanel::-webkit-scrollbar-thumb,#pauseMenu::-webkit-scrollbar-thumb{background:#1f5063;border-radius:10px;}
#helpPanel::-webkit-scrollbar-thumb:hover,#pauseMenu::-webkit-scrollbar-thumb:hover{background:#2d6e86;}
/* Responsive */
@media (max-width:1150px){#tasksPanel{display:none;}#helpPanel{top:55%;}}
@media (max-width:860px){#helpPanel{right:50%;translate:50% -50%;}}
@media (max-width:640px){
  #hudTop{font-size:.7rem;}
  #radar{display:none;}
  #helpPanel{width:94%;}
  #helpToggleBtn{bottom:8.5rem;}
  #toast{width:86%;}
  #tasksPanel{display:none;}
  .difficultyGrid{grid-template-columns:repeat(auto-fit,minmax(140px,1fr));}
  .diffCard{min-height:170px;}
  .settingRow{grid-template-columns:1fr;}
}
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- Loading -->
<div id="loadingScreen">
  <div class="logo">VECTOR&nbsp;CITY</div>
  <div class="barOuter"><div class="barInner" id="loadBar"></div></div>
  <div class="hint" id="loadHint">Bootstrapping simulation core...</div>
  <div class="small">Click the scene later to lock pointer (ESC opens pause/settings)</div>
</div>

<!-- Start Menu -->
<div id="startMenu" class="hidden">
  <div class="menuBox">
    <h1>PANDEMIC: VECTOR CITY</h1>
    <div class="menuSubtitle">Choose a difficulty. Tutorial recommended. All code selfâ€‘contained; open locally (file://) â€“ no server required.</div>
    <div class="difficultyGrid" id="difficultyGrid"></div>
    <button id="startButton" disabled>SELECT DIFFICULTY</button>
  </div>
</div>

<!-- HUD -->
<div id="ui">
  <div id="hudTop">
    <div class="panel" id="statsPanel">
      Infected: <span id="infectedCount">0</span>/<span id="citizenCount">0</span> |
      R(t) <span id="rtValue">0.00</span> |
      Vaccines <span id="vaccineCount">0</span> |
      Barriers <span id="barrierCount">0</span> |
      Score <span id="score">0</span>
    </div>
    <div class="panel solid"><b>Objective:</b> <span id="missionText">Select a difficulty...</span></div>
  </div>
  <div id="hudBottom">
    <div class="panel controls">WASD Move â€¢ Mouse Look â€¢ Shift Sprint â€¢ F Heal â€¢ E Barrier â€¢ Q Pulse Scan â€¢ H Help â€¢ ESC Pause</div>
    <div class="panel log" id="eventLog"></div>
  </div>
  <div id="crosshair"></div>
  <div id="storyBox" class="hidden" aria-modal="true" role="dialog"></div>
  <div id="radar"></div>
</div>

<!-- Panels -->
<div id="tasksPanel" class="hidden"></div>
<button id="helpToggleBtn" title="Toggle Help">HELP</button>
<div id="helpPanel" class="hidden">
  <h3>Containment Playbook</h3>
  <p style="margin:0 0 .4rem;">Drive <b>R(t)</b> &lt; 1.0, reduce active infections, accelerate immunity via targeted heals (F), use barriers (E) to disperse clusters, scan (Q) to reveal infected.</p>
  <div class="helpGrid">
    <kbd>WASD</kbd><div>Move</div>
    <kbd>Mouse</kbd><div>Look (click to lock)</div>
    <kbd>Shift</kbd><div>Sprint</div>
    <kbd>F</kbd><div>Heal / vaccinate targeted infected</div>
    <kbd>E</kbd><div>Deploy barrier</div>
    <kbd>Q</kbd><div>Pulse scan (temporary reveal)</div>
    <kbd>H</kbd><div>Toggle help</div>
    <kbd>ESC</kbd><div>Pause / settings</div>
  </div>
  <button class="btnClose" id="helpCloseBtn">CLOSE (H)</button>
</div>

<!-- Pause / Settings -->
<div id="pauseMenu" class="hidden">
  <div class="pausePanel">
    <h2>PAUSE / SETTINGS</h2>
    <div class="settingRow">
      <label for="bloomStrength">Bloom Strength</label>
      <div><input type="range" id="bloomStrength" min="0" max="3" step=".05" value="1.2">
        <span class="rangeVal" id="bloomStrengthVal">1.20</span></div>
    </div>
    <div class="settingRow">
      <label for="bloomRadius">Bloom Radius</label>
      <div><input type="range" id="bloomRadius" min="0" max="1" step=".01" value=".4">
        <span class="rangeVal" id="bloomRadiusVal">0.40</span></div>
    </div>
    <div class="settingRow">
      <label for="bokehFocus">DOF Focus Dist.</label>
      <div><input type="range" id="bokehFocus" min="1" max="300" step="1" value="55">
        <span class="rangeVal" id="bokehFocusVal">55</span></div>
    </div>
    <div class="settingRow">
      <label for="bokehAperture">DOF Aperture</label>
      <div><input type="range" id="bokehAperture" min="0" max="0.01" step="0.0001" value="0.0032">
        <span class="rangeVal" id="bokehApertureVal">0.0032</span></div>
    </div>
    <div class="settingRow">
      <label for="exposure">Exposure</label>
      <div><input type="range" id="exposure" min="0.3" max="2" step=".01" value="1">
        <span class="rangeVal" id="exposureVal">1.00</span></div>
    </div>
    <div class="settingRow">
      <label for="renderScale">Render Scale</label>
      <div><input type="range" id="renderScale" min=".5" max="1" step=".01" value="1">
        <span class="rangeVal" id="renderScaleVal">1.00</span></div>
    </div>
    <div class="settingRow">
      <label>Effects</label>
      <div style="display:flex;gap:1rem;flex-wrap:wrap;">
        <label><input type="checkbox" id="toggleBloom" checked> Bloom</label>
        <label><input type="checkbox" id="toggleDOF" checked> DOF</label>
        <label><input type="checkbox" id="toggleVignette" checked> Vignette</label>
      </div>
    </div>
    <div style="display:flex;gap:.9rem;flex-wrap:wrap;">
      <button class="bigBtn" id="resumeBtn">RESUME (ESC)</button>
      <button class="bigBtn" id="restartBtn">RESTART</button>
      <button class="bigBtn danger" id="quitBtn">QUIT TO MENU</button>
    </div>
  </div>
</div>

<!-- Tutorial Pulse + Toast -->
<div id="tutorialPulse" class="hidden"></div>
<div id="toast"></div>

<!-- Glow Filter (optional reference) -->
<svg width="0" height="0"><defs><filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="6" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs></svg>

<script type="module">
/* =============================================================================
   PANDEMIC: VECTOR CITY â€“ COMPLETE EDITION
   - FULL FEATURE SET RESTORED
   - DIFFICULTY SELECTION FIXED
   - STORY / MODAL DISMISS RELIABILITY FIXED
   - POINTER LOCK SECURITYERROR PREVENTION
   - POST PROCESSING (Bloom + DOF + Vignette) RESTORED
   ========================================================================== */

/* ---------------------------------- Imports -------------------------------- */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass }     from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass }from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { BokehPass }      from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/BokehPass.js';
import { ShaderPass }     from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';

/* --------------------------------- Utilities -------------------------------- */
const rand=(a=0,b=1)=>Math.random()*(b-a)+a;
const randInt=(a,b)=>Math.floor(rand(a,b+1));
const clamp=(v,a,b)=>v<a?a:v>b?b:v;
const format=n=>Intl.NumberFormat().format(n);
function uuid(){return crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)+Date.now().toString(36);}
if(!String.prototype.hashCode){Object.defineProperty(String.prototype,'hashCode',{value:function(){let h=0;for(let i=0;i<this.length;i++){h=((h<<5)-h)+this.charCodeAt(i);h|=0;}return h;}});}
function valueNoise2D(x,y){const xi=Math.floor(x),yi=Math.floor(y),xf=x-xi,yf=y-yi;
  const r=(ix,iy)=>{const s=Math.sin(ix*127.1+iy*311.7)*43758.5453;return s-Math.floor(s);};
  const v00=r(xi,yi),v10=r(xi+1,yi),v01=r(xi,yi+1),v11=r(xi+1,yi+1);
  const u=t=>t*t*(3-2*t);const ux=u(xf),uy=u(yf);
  return THREE.MathUtils.lerp(THREE.MathUtils.lerp(v00,v10,ux),THREE.MathUtils.lerp(v01,v11,ux),uy);
}
const Events={listeners:{},on(n,f){(this.listeners[n] ||= []).push(f);},emit(n,d){(this.listeners[n]||[]).forEach(fn=>fn(d));}};
class RollingStat{constructor(size=120){this.size=size;this.values=[];}push(v){this.values.push(v);if(this.values.length>this.size)this.values.shift();}}

/* ------------------------------ Difficulty Data --------------------------- */
const DIFFICULTIES={
  tutorial:{key:'tutorial',label:'Tutorial / Easy',desc:'Guided low-pressure introduction.',citizens:40,initialInfected:3,infectiousnessScale:.85,spreadMultiplier:.85,pickupRate:.35,startVaccines:4,startBarriers:2,tutorial:true},
  easy:{key:'easy',label:'Easy',desc:'Relaxed challenge.',citizens:55,initialInfected:5,infectiousnessScale:1,spreadMultiplier:1,pickupRate:.30,startVaccines:3,startBarriers:2},
  normal:{key:'normal',label:'Normal',desc:'Balanced progression.',citizens:70,initialInfected:9,infectiousnessScale:1.05,spreadMultiplier:1.08,pickupRate:.26,startVaccines:2,startBarriers:1},
  hard:{key:'hard',label:'Hard',desc:'Elevated transmission.',citizens:86,initialInfected:14,infectiousnessScale:1.12,spreadMultiplier:1.18,pickupRate:.22,startVaccines:2,startBarriers:1},
  overrun:{key:'overrun',label:'Overrun',desc:'Severe outbreak intensity.',citizens:110,initialInfected:24,infectiousnessScale:1.22,spreadMultiplier:1.25,pickupRate:.18,startVaccines:1,startBarriers:1}
};

const GameState={
  difficulty:null,
  started:false,
  tutorialActive:false,
  paused:false,
  pointerLockPending:false,
  effects:{bloom:true,dof:true,vignette:true}
};

/* -------------------------------- Input System ---------------------------- */
const Input={
  keys:new Set(),
  mouse:{dx:0,dy:0,locked:false},
  sprint:false,
  init(canvas){
    addEventListener('keydown',e=>{
      if(['KeyF','KeyE','KeyQ','KeyH','Digit1','Digit2'].includes(e.code)) e.preventDefault();
      this.keys.add(e.code);
      if(e.code==='ShiftLeft') this.sprint=true;
      if(e.code==='KeyH') UI.toggleHelp();
      if(e.code==='Escape' && GameState.started) Pause.toggle();
    });
    addEventListener('keyup',e=>{
      this.keys.delete(e.code);
      if(e.code==='ShiftLeft') this.sprint=false;
    });
    canvas.addEventListener('click',()=>{
      if(!GameState.started||GameState.paused) return;
      if(document.pointerLockElement||GameState.pointerLockPending) return;
      try{
        GameState.pointerLockPending=true;
        canvas.requestPointerLock({unadjustedMovement:true});
      }catch(err){GameState.pointerLockPending=false;}
    });
    document.addEventListener('pointerlockchange',()=>{
      Input.mouse.locked=!!document.pointerLockElement;
      GameState.pointerLockPending=false;
    });
    document.addEventListener('pointerlockerror',()=>{GameState.pointerLockPending=false;});
    addEventListener('mousemove',e=>{
      if(this.mouse.locked && !GameState.paused){
        this.mouse.dx+=e.movementX; this.mouse.dy+=e.movementY;
      }
    },{passive:true});
    addEventListener('blur',()=>this.keys.clear());
  },
  consumeMouseDelta(){const d={dx:this.mouse.dx,dy:this.mouse.dy}; this.mouse.dx=0; this.mouse.dy=0; return d;},
  isDown(code){return this.keys.has(code);}
};

/* -------------------------------- Audio ----------------------------------- */
const AudioSys={
  ctx:null,master:null,musicGain:null,fxGain:null,unlocked:false,
  init(){addEventListener('click',()=>this.unlock(),{once:true});},
  unlock(){
    if(this.unlocked) return;
    this.ctx=new (window.AudioContext||window.webkitAudioContext)();
    this.master=this.ctx.createGain();
    this.musicGain=this.ctx.createGain();
    this.fxGain=this.ctx.createGain();
    this.musicGain.gain.value=.22; this.fxGain.gain.value=.55;
    this.musicGain.connect(this.master); this.fxGain.connect(this.master); this.master.connect(this.ctx.destination);
    this.startMusic(); this.unlocked=true;
  },
  startMusic(){
    const notes=[220,247,262,294,330,349,392,440,494];
    const tempo=84;
    const schedule=()=>{
      if(!this.unlocked) return;
      const t=this.ctx.currentTime;
      for(let i=0;i<8;i++){
        const time=t+i*60/tempo;
        const f=notes[(i*3 + (Math.random()<.5?0:1))%notes.length]/2;
        this.tone(f,.38,time,.18,'sine',this.musicGain,.02);
        if(i%4===0) this.tone(f*2,.18,time+.18,.12,'triangle',this.musicGain,.005);
      }
      setTimeout(schedule,(60/tempo)*1000*8);
    };
    schedule();
  },
  tone(freq,len,whenGain=.3,type='sine',out,attack=.02){
    const ctx=this.ctx, t=ctx.currentTime, o=ctx.createOscillator(), g=ctx.createGain();
    o.type=type; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(whenGain,t+attack);
    g.gain.exponentialRampToValueAtTime(0.0001,t+len); o.frequency.setValueAtTime(freq,t);
    o.connect(g).connect(out||this.fxGain); o.start(t); o.stop(t+len+.05);
  },
  blip(kind){
    if(!this.unlocked) return;
    if(kind==='infect') this.tone(95,.6,.55,'square');
    else if(kind==='heal') this.tone(640,.35,.45,'triangle');
    else if(kind==='barrier') this.tone(330,.55,.42,'sawtooth');
    else if(kind==='scan'){for(let i=0;i<6;i++) this.tone(240+i*50,.16,.22,'sine');}
    else if(kind==='task') this.tone(880,.25,.3,'sine');
    else this.tone(440,.25,.3,'sine');
  }
};
AudioSys.init(); Events.on('audio',e=>AudioSys.blip(e.kind));

/* -------------------------------- Entities -------------------------------- */
const ENTITY_TYPES={PLAYER:'player',CITIZEN:'citizen',PICKUP:'pickup',BARRIER:'barrier',PARTICLE:'particle'};
class Entity{constructor(type){this.id=uuid();this.type=type;this.dead=false;this.mesh=null;this.pos=new THREE.Vector3();this.vel=new THREE.Vector3();}}
class Player extends Entity{
  constructor(cfg){super(ENTITY_TYPES.PLAYER);
    this.speed=10;
    this.inventory={vaccines:cfg.startVaccines,barriers:cfg.startBarriers};
    this.cooldowns={vaccine:0,barrier:0,scan:0};
    this.score=0;
  }
}
class Citizen extends Entity{
  constructor(scale){
    super(ENTITY_TYPES.CITIZEN);
    this.state='healthy';
    this.timer=0;
    this.nextStateTime=0;
    this.infectiousness=clamp(rand(.42,.95)*scale,0,.999);
    this.speed=rand(2.3,3.1);
    this.target=new THREE.Vector3();
  }
}
class Pickup extends Entity{constructor(kind='vaccine'){super(ENTITY_TYPES.PICKUP);this.kind=kind;this.spin=rand(-2,2);}}
class Barrier extends Entity{constructor(){super(ENTITY_TYPES.BARRIER);this.life=25;}}
class Particle extends Entity{constructor(color){super(ENTITY_TYPES.PARTICLE);this.life=1;this.color=color;}}

const EntityFactory={
  citizenMaterials:{
    healthy:new THREE.MeshStandardMaterial({color:0xa3e6ff,roughness:.58,metalness:.12}),
    infected:new THREE.MeshStandardMaterial({color:0xff3d55,emissive:0x770d21,emissiveIntensity:.9,roughness:.4}),
    recovering:new THREE.MeshStandardMaterial({color:0xffb347,emissive:0x553012,emissiveIntensity:.55}),
    immune:new THREE.MeshStandardMaterial({color:0x4dffd7,emissive:0x0f5842,emissiveIntensity:.65})
  },
  citizenGeometry:new THREE.CapsuleGeometry(.38,1.2,8,14),
  createCitizen(){
    const c=new Citizen(GameState.difficulty?.infectiousnessScale||1);
    c.mesh=new THREE.Mesh(this.citizenGeometry,this.citizenMaterials.healthy);
    c.mesh.castShadow=true;c.mesh.receiveShadow=true;
    c.pos.set(rand(-22,22),0,rand(-22,22));
    c.mesh.position.copy(c.pos);
    return c;
  },
  updateCitizenMaterial(c){c.mesh.material=this.citizenMaterials[c.state];},
  createPickup(kind){
    const p=new Pickup(kind);
    p.mesh=new THREE.Mesh(new THREE.DodecahedronGeometry(.45),
      new THREE.MeshStandardMaterial({color:kind==='vaccine'?0x4dffd7:0x6ac8ff,emissive:kind==='vaccine'?0x0f5c44:0x0e4263,emissiveIntensity:.95,metalness:.4,roughness:.2}));
    p.mesh.castShadow=true;
    p.mesh.position.set(rand(-18,18),.7,rand(-18,18));
    p.pos.copy(p.mesh.position);
    return p;
  },
  createBarrier(pos){
    const b=new Barrier();
    b.mesh=new THREE.Mesh(new THREE.CylinderGeometry(.25,.25,3,24,1,true),
      new THREE.MeshStandardMaterial({color:0x6ac8ff,emissive:0x1c5a7a,emissiveIntensity:1,transparent:true,opacity:.5,roughness:.15,metalness:.65}));
    b.mesh.position.copy(pos).y=1.5;
    b.pos.copy(b.mesh.position); b.mesh.castShadow=true;
    return b;
  },
  createParticle(color){
    const pr=new Particle(color);
    pr.mesh=new THREE.Mesh(new THREE.SphereGeometry(.09,8,8),
      new THREE.MeshBasicMaterial({color,transparent:true}));
    return pr;
  }
};

/* -------------------------------- World / Scene --------------------------- */
const World={
  scene:null,renderer:null,camera:null,clock:null,sun:null,sky:null,
  composer:null,bloomPass:null,bokehPass:null,renderPass:null,vignettePass:null,
  init(canvas){
    this.scene=new THREE.Scene();
    this.scene.background=new THREE.Color(0x0d1822);
    this.scene.fog=new THREE.FogExp2(0x0e1f2d,.03);
    this.camera=new THREE.PerspectiveCamera(72,innerWidth/innerHeight,.08,500);
    this.camera.position.set(0,2.1,6);
    this.renderer=new THREE.WebGLRenderer({canvas,antialias:true});
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(innerWidth,innerHeight);
    this.renderer.shadowMap.enabled=true;
    this.renderer.shadowMap.type=THREE.PCFSoftShadowMap;
    this.clock=new THREE.Clock();
    this.setupLights();
    this.buildCity();
    this.buildSky();
    this.addAmbientParticles();
    this.initPostFX();
    addEventListener('resize',()=>this.onResize());
  },
  setupLights(){
    const sun=new THREE.DirectionalLight(0xffffff,3.2);
    sun.position.set(24,48,16); sun.castShadow=true;
    sun.shadow.mapSize.set(2048,2048);
    Object.assign(sun.shadow.camera,{left:-70,right:70,top:70,bottom:-70});
    this.scene.add(sun); this.sun=sun;
    const fill=new THREE.DirectionalLight(0x4dffd7,1.15);
    fill.position.set(-40,30,-25);
    this.scene.add(fill);
    this.scene.add(new THREE.HemisphereLight(0x8dd6ff,0x13242e,.55));
  },
  buildSky(){
    const geo=new THREE.SphereGeometry(200,60,40);
    const mat=new THREE.ShaderMaterial({
      side:THREE.BackSide,
      uniforms:{top:{value:new THREE.Color(0x133b58)},mid:{value:new THREE.Color(0x276b8d)},bot:{value:new THREE.Color(0x0a1923)},t:{value:0}},
      fragmentShader:`uniform vec3 top;uniform vec3 mid;uniform vec3 bot;uniform float t;varying vec3 vPos;
      void main(){
        float h=normalize(vPos).y*.5+.5;
        vec3 c=mix(bot,mid,smoothstep(0.,1.,clamp(h/0.55,0.,1.)));
        if(h>0.55){
          float k=(h-0.55)/0.45;
          c=mix(c,top,smoothstep(0.,1.,k));
        }
        float dm=.5+.5*sin(t*0.05);
        c=mix(c,vec3(.98,.82,.62),.12*dm);
        gl_FragColor=vec4(c,1.);
      }`,
      vertexShader:`varying vec3 vPos;void main(){vPos=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);} `
    });
    this.sky=new THREE.Mesh(geo,mat);
    this.scene.add(this.sky);
  },
  buildCity(){
    const ground=new THREE.Mesh(new THREE.PlaneGeometry(320,320),
      new THREE.MeshStandardMaterial({color:0x123043,roughness:.85,metalness:.05}));
    ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; this.scene.add(ground);
    const palette=[0x134255,0x1b5165,0x246174,0x2f7288];
    const group=new THREE.Group();
    for(let x=-6;x<=6;x++){
      for(let z=-6;z<=6;z++){
        if((Math.abs(x)<2 && Math.abs(z)<2)||(x%2||z%2)) continue;
        const h=6+valueNoise2D(x*.7,z*.7)*34;
        const mat=new THREE.MeshStandardMaterial({color:palette[(Math.abs(x)+Math.abs(z))%palette.length],roughness:.78,metalness:.18,emissive:0x092538,emissiveIntensity:.55});
        const m=new THREE.Mesh(new THREE.BoxGeometry(7,h,7),mat);
        m.position.set(x*9,h/2,z*9); m.castShadow=true; m.receiveShadow=true;
        // window panels (faux light)
        const winMat=new THREE.MeshBasicMaterial({color:0x4dffd7,transparent:true,opacity:.085});
        const w1=new THREE.Mesh(new THREE.PlaneGeometry(6.6,h*.85),winMat); w1.position.set(0,0,.01-h/200); m.add(w1);
        const w2=w1.clone(); w2.position.z*=-1; w2.rotation.y=Math.PI; m.add(w2);
        group.add(m);
      }
    }
    this.scene.add(group);
  },
  addAmbientParticles(){
    const count=520;
    const geo=new THREE.BufferGeometry();
    const pos=new Float32Array(count*3);
    for(let i=0;i<count;i++){
      pos[i*3]=rand(-120,120);
      pos[i*3+1]=rand(2,48);
      pos[i*3+2]=rand(-120,120);
    }
    geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
    const mat=new THREE.PointsMaterial({color:0x4dffd7,size:.55,sizeAttenuation:true,transparent:true,opacity:.18,blending:THREE.AdditiveBlending,depthWrite:false});
    this.scene.add(new THREE.Points(geo,mat));
  },
  initPostFX(){
    this.composer=new EffectComposer(this.renderer);
    this.renderPass=new RenderPass(this.scene,this.camera);
    this.composer.addPass(this.renderPass);
    this.bloomPass=new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight),1.2,.4,.85);
    this.composer.addPass(this.bloomPass);
    this.bokehPass=new BokehPass(this.scene,this.camera,{
      focus:55,
      aperture:0.0032,
      maxblur:0.009,
      width:innerWidth,
      height:innerHeight
    });
    this.composer.addPass(this.bokehPass);
    const vignetteShader={
      uniforms:{tDiffuse:{value:null},offset:{value:1.1},darkness:{value:1.25},enabled:{value:1}},
      vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
      fragmentShader:`uniform sampler2D tDiffuse;uniform float offset;uniform float darkness;uniform float enabled;varying vec2 vUv;
      void main(){
        vec4 c=texture2D(tDiffuse,vUv);
        if(enabled<.5){gl_FragColor=c;return;}
        vec2 pos=vUv-.5;
        float len=length(pos);
        float vig=smoothstep(offset,darkness,len*1.4);
        c.rgb*=1.0 - .6*vig;
        gl_FragColor=c;
      }`
    };
    this.vignettePass=new ShaderPass(vignetteShader);
    this.composer.addPass(this.vignettePass);
    Settings.applyEffects(); // sync toggles
  },
  onResize(){
    this.camera.aspect=innerWidth/innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(innerWidth,innerHeight);
    this.composer?.setSize(innerWidth,innerHeight);
  },
  render(){
    if(this.composer) this.composer.render();
    else this.renderer.render(this.scene,this.camera);
  }
};

/* -------------------------------- ECS ------------------------------------- */
const ECS={
  player:null,citizens:[],pickups:[],barriers:[],particles:[],
  infectionStat:new RollingStat(300),rtValue:0,
  add(e){
    if(e.type==='player') this.player=e;
    if(e.type==='citizen') this.citizens.push(e);
    else if(e.type==='pickup') this.pickups.push(e);
    else if(e.type==='barrier') this.barriers.push(e);
    else if(e.type==='particle') this.particles.push(e);
    if(e.mesh) World.scene.add(e.mesh);
  },
  remove(e){
    e.dead=true;
    if(e.mesh){World.scene.remove(e.mesh); e.mesh.geometry?.dispose(); e.mesh.material?.dispose();}
  },
  countInfected(){return this.citizens.filter(c=>c.state==='infected').length;}
};

/* -------------------------------- Player System --------------------------- */
const PlayerSystem={
  yaw:0,pitch:0,cameraHeight:1.85,ray:new THREE.Raycaster(),
  moveAccum:0,lastPos:new THREE.Vector3(),
  update(dt){
    if(GameState.paused) return;
    const p=ECS.player; if(!p) return;
    const {dx,dy}=Input.consumeMouseDelta();
    this.yaw -= dx*0.0024;
    this.pitch = clamp(this.pitch - dy*0.002,-Math.PI/2+0.2,Math.PI/2-0.2);
    const lookDir=new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(1,0,0),this.pitch).applyAxisAngle(new THREE.Vector3(0,1,0),this.yaw);
    const forwardXZ=lookDir.clone().setY(0); if(forwardXZ.lengthSq()<1e-6) forwardXZ.set(0,0,-1); forwardXZ.normalize();
    const rightXZ=new THREE.Vector3(forwardXZ.z,0,-forwardXZ.x);
    const move=new THREE.Vector3();
    if(Input.isDown('KeyW')) move.add(forwardXZ);
    if(Input.isDown('KeyS')) move.sub(forwardXZ);
    if(Input.isDown('KeyA')) move.sub(rightXZ);
    if(Input.isDown('KeyD')) move.add(rightXZ);
    if(move.lengthSq()) move.normalize();
    p.pos.addScaledVector(move,(Input.sprint?1.85:1)*p.speed*dt);
    p.pos.x=clamp(p.pos.x,-90,90); p.pos.z=clamp(p.pos.z,-90,90);
    World.camera.position.copy(p.pos).y=this.cameraHeight;
    World.camera.lookAt(World.camera.position.clone().add(lookDir));
    this.moveAccum+=p.pos.distanceTo(this.lastPos); this.lastPos.copy(p.pos);

    // cooldowns
    Object.keys(p.cooldowns).forEach(k=>p.cooldowns[k]=Math.max(0,p.cooldowns[k]-dt));
    if(Input.isDown('KeyF') && !p.cooldowns.vaccine && p.inventory.vaccines>0){ this.tryHeal(); p.cooldowns.vaccine=.75; }
    if(Input.isDown('KeyE') && !p.cooldowns.barrier && p.inventory.barriers>0){ this.deployBarrier(); p.cooldowns.barrier=2.5; }
    if(Input.isDown('KeyQ') && !p.cooldowns.scan){ this.scanPulse(); p.cooldowns.scan=5.5; }
  },
  tryHeal(){
    const dir=new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(1,0,0),this.pitch).applyAxisAngle(new THREE.Vector3(0,1,0),this.yaw).normalize();
    this.ray.set(World.camera.position,dir);
    const hits=this.ray.intersectObjects(ECS.citizens.map(c=>c.mesh));
    if(hits.length){
      const c=ECS.citizens.find(cc=>cc.mesh===hits[0].object);
      if(c && c.state==='infected'){
        c.state='recovering'; c.timer=0; c.nextStateTime=rand(7,13); EntityFactory.updateCitizenMaterial(c);
        ECS.player.inventory.vaccines--; ECS.player.score+=160;
        Events.emit('log',{text:'Healed infection (accelerated immunity)',cls:'good'});
        Events.emit('audio',{kind:'heal'});
        Tutorial.flag('healedCitizen');
      }
    }
  },
  deployBarrier(){
    const forward=new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(1,0,0),this.pitch).applyAxisAngle(new THREE.Vector3(0,1,0),this.yaw).setY(0).normalize();
    const pos=ECS.player.pos.clone().addScaledVector(forward,2.4);
    const b=EntityFactory.createBarrier(pos); ECS.add(b);
    ECS.player.inventory.barriers--; ECS.player.score+=55;
    Events.emit('log',{text:'Barrier deployed',cls:'good'}); Events.emit('audio',{kind:'barrier'}); Tutorial.flag('deployedBarrier');
  },
  scanPulse(){
    ECS.player.score+=18;
    Events.emit('log',{text:'Pulse scan emitted',cls:'good'}); Events.emit('audio',{kind:'scan'}); Tutorial.flag('usedScan');
    ECS.citizens.forEach(c=>{
      if(c.state==='infected'){
        const m=c.mesh.material; const orig=m.emissiveIntensity;
        m.emissiveIntensity=1.65;
        setTimeout(()=>{if(!c.dead && c.state==='infected') m.emissiveIntensity=orig;},700);
      }
    });
  }
};

/* -------------------------------- Systems --------------------------------- */
function spawnParticle(origin){
  const p=EntityFactory.createParticle(0xff3d55);
  p.pos.copy(origin).add(new THREE.Vector3(rand(-.5,.5),rand(.3,1.6),rand(-.5,.5)));
  p.mesh.position.copy(p.pos);
  p.vel.set(rand(-.25,.25),rand(.6,1.4),rand(-.25,.25));
  ECS.particles.push(p);
  World.scene.add(p.mesh);
}
const ParticleSystem={
  update(dt){
    ECS.particles.forEach(p=>{
      p.life-=dt;
      p.mesh.position.addScaledVector(p.vel,dt);
      p.mesh.material.opacity=clamp(p.life,0,1);
      if(p.life<=0) ECS.remove(p);
    });
    ECS.particles=ECS.particles.filter(p=>!p.dead);
  }
};
const PickupSystem={
  update(dt){
    ECS.pickups.forEach(p=>{
      if(p.dead)return;
      p.mesh.rotation.y+=dt*p.spin;
      p.mesh.position.y=0.7+Math.sin(performance.now()/500 + p.id.hashCode())*0.22;
      if(p.pos.distanceTo(ECS.player.pos)<1.5){
        (p.kind==='vaccine'?ECS.player.inventory.vaccines++:ECS.player.inventory.barriers++);
        ECS.player.score+=48;
        p.dead=true; World.scene.remove(p.mesh);
        Events.emit('log',{text:`Collected ${p.kind}`,cls:'good'}); Events.emit('audio',{kind:'pickup'}); Tutorial.flag('collectedPickup');
      }
    });
    ECS.pickups=ECS.pickups.filter(p=>!p.dead);
  }
};
const BarrierSystem={
  update(dt){
    ECS.barriers.forEach(b=>{
      b.life-=dt;
      const s=1+Math.sin(performance.now()/230)*0.09;
      b.mesh.scale.set(s,1,s);
      b.mesh.material.opacity=.4+.1*Math.sin(performance.now()/300 + b.id.hashCode());
      if(b.life<=0) ECS.remove(b);
    });
    ECS.barriers=ECS.barriers.filter(b=>!b.dead);
  }
};
const CollisionSystem={
  update(dt){
    ECS.citizens.forEach(c=>{
      ECS.barriers.forEach(b=>{
        const dist=c.pos.distanceTo(b.pos);
        if(dist<2.6){
          const dir=c.pos.clone().sub(b.pos).setY(0);
          const len=dir.length();
          if(len>0){
            dir.normalize();
            c.pos.addScaledVector(dir,(2.6-dist)*2.6*dt);
            c.mesh.position.copy(c.pos);
          }
        }
      });
    });
  }
};
const InfectionSystem={
  update(dt){
    const inf=ECS.countInfected();
    ECS.infectionStat.push(inf);
    if(ECS.infectionStat.values.length>120){
      const recent=ECS.infectionStat.values.slice(-60);
      const earlier=ECS.infectionStat.values.slice(-120,-60);
      const diff=a=>{if(a.length<2)return 0;let s=0;for(let i=1;i<a.length;i++)s+=a[i]-a[i-1];return s/(a.length-1);};
      const rR=diff(recent), rE=diff(earlier);
      const r=rE===0?(rR>0?1.3:0):rR/Math.abs(rE);
      ECS.rtValue=isFinite(r)?r:0;
    }
    const rate=GameState.difficulty?.pickupRate??0.3;
    if(ECS.pickups.length<8 && Math.random()<dt*rate){
      ECS.add(EntityFactory.createPickup(Math.random()<.66?'vaccine':'barrier'));
    }
    if(Math.random()<dt*10){
      const c=ECS.citizens[randInt(0,ECS.citizens.length-1)];
      if(c && c.state==='infected') spawnParticle(c.pos);
    }
  }
};
const AI={
  sim(dt){
    ECS.citizens.forEach(c=>{
      c.timer+=dt;
      if(c.state==='infected' && c.timer>=c.nextStateTime){
        c.state='recovering'; c.timer=0; c.nextStateTime=rand(6,12); EntityFactory.updateCitizenMaterial(c);
      } else if(c.state==='recovering' && c.timer>=c.nextStateTime){
        c.state='immune'; c.timer=0; EntityFactory.updateCitizenMaterial(c);
      }
      if(!c.target || c.pos.distanceTo(c.target)<0.6){
        c.target.set(c.pos.x+rand(-12,12),0,c.pos.z+rand(-12,12));
      }
      const d=c.target.clone().sub(c.pos);
      const len=d.length();
      if(len>0.001){
        d.normalize();
        c.pos.addScaledVector(d,c.speed*dt);
        c.mesh.position.copy(c.pos);
        c.mesh.rotation.y=Math.atan2(d.x,d.z);
      }
      c.mesh.position.y=Math.sin(performance.now()/430 + c.id.hashCode()*0.07)*0.07;
    });
  },
  spread(dt){
    const mult=GameState.difficulty?.spreadMultiplier||1;
    const arr=ECS.citizens;
    for(let i=0;i<arr.length;i++){
      const a=arr[i]; if(a.state!=='infected') continue;
      for(let j=i+1;j<arr.length;j++){
        const b=arr[j]; if(b.state!=='healthy') continue;
        const dist=a.pos.distanceTo(b.pos);
        if(dist<1.85){
          const chance=clamp((1.85-dist)/1.85,0,1)*a.infectiousness*dt*0.95*mult;
          if(Math.random()<chance){
            b.state='infected'; b.timer=0; b.nextStateTime=rand(11,19);
            EntityFactory.updateCitizenMaterial(b);
            spawnParticle(b.pos);
            Events.emit('log',{text:'Infection event detected',cls:'infect'});
            Events.emit('audio',{kind:'infect'});
          }
        }
      }
    }
  }
};

/* -------------------------------- Tutorial System ------------------------- */
const Tutorial={
  steps:[],currentIndex:0,flags:{},movementNeeded:4,
  init(){
    if(!GameState.difficulty?.tutorial){ GameState.tutorialActive=false; return; }
    GameState.tutorialActive=true;
    this.steps=[
      {id:'move',title:'Move',text:'Use WASD to move.',cond:()=>PlayerSystem.moveAccum>this.movementNeeded},
      {id:'pickup',title:'Collect Supply',text:'Collect a pickup (glowing poly).',setup:()=>this.spawnPickupNear(),cond:()=>this.flags.collectedPickup},
      {id:'scan',title:'Pulse Scan',text:'Press Q to highlight infected.',cond:()=>this.flags.usedScan},
      {id:'heal',title:'Heal',text:'Aim at infected & press F.',setup:()=>this.spawnInfectedNear(),cond:()=>this.flags.healedCitizen},
      {id:'barrier',title:'Barrier',text:'Press E to deploy barrier.',cond:()=>this.flags.deployedBarrier},
      {id:'done',title:'Containment Active',text:'Tutorial complete â€“ continue stabilizing.',cond:()=>true,final:true}
    ];
    this.render();
    this.showToast('Move using WASD to begin.');
  },
  flag(n){this.flags[n]=true; this.evaluate();},
  evaluate(){
    if(!GameState.tutorialActive) return;
    const step=this.steps[this.currentIndex];
    if(step && step.cond()){
      this.currentIndex++;
      if(this.currentIndex<this.steps.length){
        const nxt=this.steps[this.currentIndex];
        if(nxt.setup) nxt.setup();
        this.showToast(nxt.title+': '+nxt.text);
      } else {
        GameState.tutorialActive=false;
        this.showToast('Tutorial complete. Operative cleared.');
      }
      this.render();
    }
  },
  spawnPickupNear(){
    const pk=EntityFactory.createPickup('vaccine');
    pk.mesh.position.copy(ECS.player.pos).add(new THREE.Vector3(2,0,0));
    pk.pos.copy(pk.mesh.position);
    ECS.add(pk);
  },
  spawnInfectedNear(){
    const c=EntityFactory.createCitizen();
    c.state='infected'; c.timer=0; c.nextStateTime=rand(10,16); EntityFactory.updateCitizenMaterial(c);
    c.pos.copy(ECS.player.pos).add(new THREE.Vector3(4,0,-2)); c.mesh.position.copy(c.pos); ECS.add(c);
  },
  render(){
    const panel=document.getElementById('tasksPanel');
    if(!GameState.tutorialActive){ panel.classList.add('hidden'); return; }
    panel.classList.remove('hidden');
    panel.innerHTML='<h3>Tutorial</h3>';
    this.steps.forEach((s,i)=>{
      const div=document.createElement('div');
      div.className='taskItem'+(i===this.currentIndex?' current':'')+(i<this.currentIndex?' done':'');
      div.innerHTML=`<div class="taskCheck">${i<this.currentIndex?'âœ“':(i===this.currentIndex?'â–¶':'')}</div>
        <div><b>${s.title}</b><br><span style="opacity:.7;">${s.text}</span></div>`;
      panel.appendChild(div);
    });
  },
  showToast(msg){
    const t=document.getElementById('toast');
    t.textContent=msg;
    t.classList.add('visible');
    setTimeout(()=>t.classList.remove('visible'),4700);
  }
};

/* -------------------------------- UI Layer -------------------------------- */
const UI={
  els:{},
  init(){
    const ids=['infectedCount','citizenCount','rtValue','vaccineCount','barrierCount','score','eventLog','storyBox','loadBar','loadHint','missionText'];
    ids.forEach(id=>this.els[id]=document.getElementById(id));
    Events.on('log',e=>this.addLog(e.text,e.cls));
    Events.on('story',e=>this.showStory(e.html));
    Events.on('tick',()=>this.update());
    this.animateLoader();
    this.bindHelp();
  },
  update(){
    if(!ECS.player) return;
    this.els.infectedCount.textContent=format(ECS.countInfected());
    this.els.citizenCount.textContent=format(ECS.citizens.length);
    this.els.rtValue.textContent=ECS.rtValue.toFixed(2);
    this.els.vaccineCount.textContent=ECS.player.inventory.vaccines;
    this.els.barrierCount.textContent=ECS.player.inventory.barriers;
    this.els.score.textContent=format(ECS.player.score);
  },
  addLog(text,cls){
    const line=document.createElement('div');
    line.className='logLine'+(cls?(' '+cls):'');
    line.innerHTML=text;
    this.els.eventLog.prepend(line);
    while(this.els.eventLog.children.length>35) this.els.eventLog.removeChild(this.els.eventLog.lastChild);
  },
  showStory(html){
    const sb=this.els.storyBox;
    // Robust dismiss fix: use overlay events + button + ESC + Enter
    sb.innerHTML = html + `<button class="storyCloseBtn" id="storyCloseActual">CONTINUE (Enter)</button>`;
    sb.classList.remove('hidden');
    const btn=sb.querySelector('#storyCloseActual');
    const close=()=>{
      sb.classList.add('hidden');
      btn.removeEventListener('click',close);
      document.removeEventListener('keydown',keyHandler);
      window.removeEventListener('mousedown',outside);
    };
    const keyHandler=e=>{if(e.key==='Enter' || e.key===' ') close();};
    const outside=e=>{ if(!sb.contains(e.target)) close(); };
    btn.addEventListener('click',close);
    setTimeout(()=>window.addEventListener('mousedown',outside),10);
    document.addEventListener('keydown',keyHandler);
  },
  hideLoading(){
    const l=document.getElementById('loadingScreen');
    if(!l)return;
    l.classList.add('fadeOut');
    setTimeout(()=>l.remove(),720);
    document.getElementById('startMenu').classList.remove('hidden');
  },
  animateLoader(){
    let pct=0;
    const loop=()=>{
      if(!this.els.loadBar)return;
      pct=Math.min(100,pct+rand(5,11));
      this.els.loadBar.style.width=pct+'%';
      if(pct<100) setTimeout(loop,rand(70,140));
      else setTimeout(()=>this.hideLoading(),420);
    };
    loop();
  },
  bindHelp(){
    const panel=document.getElementById('helpPanel');
    document.getElementById('helpToggleBtn').addEventListener('click',()=>panel.classList.toggle('hidden'));
    document.getElementById('helpCloseBtn').addEventListener('click',()=>panel.classList.add('hidden'));
  },
  toggleHelp(){ document.getElementById('helpPanel').classList.toggle('hidden'); }
};

/* ------------------------------ Difficulty Menu --------------------------- */
const DifficultyMenu={
  selectedKey:null,
  grid:document.getElementById('difficultyGrid'),
  startBtn:document.getElementById('startButton'),
  init(){
    Object.values(DIFFICULTIES).forEach(diff=>{
      const card=document.createElement('div');
      card.className='diffCard';
      card.dataset.diff=diff.key;
      card.innerHTML=`<div class="diffTitle">${diff.label} <span class="badge">${diff.tutorial?'GUIDED':'MODE'}</span></div>
        <div class="diffDesc">${diff.desc}</div>
        <div style="margin-top:auto;font-size:.55rem;opacity:.6;">Pop: ${diff.citizens} â€¢ Init Inf: ${diff.initialInfected}</div>`;
      card.addEventListener('click',()=>this.select(diff.key,card));
      this.grid.appendChild(card);
    });
    this.startBtn.addEventListener('click',()=>this.startGame());
  },
  select(key,el){
    this.selectedKey=key;
    document.querySelectorAll('.diffCard').forEach(c=>c.classList.remove('selected'));
    el.classList.add('selected');
    this.startBtn.disabled=false;
    this.startBtn.textContent='START ('+DIFFICULTIES[key].label.toUpperCase()+')';
  },
  startGame(){
    if(!this.selectedKey) return;
    GameState.difficulty=DIFFICULTIES[this.selectedKey];
    document.getElementById('startMenu').classList.add('fadeOut');
    setTimeout(()=>document.getElementById('startMenu')?.remove(),650);
    startSimulationWithDifficulty(GameState.difficulty);
  }
};

/* ------------------------------ Settings / Pause -------------------------- */
const Settings={
  init(){
    const pairs=[
      ['bloomStrength','bloomStrengthVal',v=>World.bloomPass&&(World.bloomPass.strength=v)],
      ['bloomRadius','bloomRadiusVal',v=>World.bloomPass&&(World.bloomPass.radius=v)],
      ['bokehFocus','bokehFocusVal',v=>World.bokehPass&&(World.bokehPass.uniforms.focus.value=v)],
      ['bokehAperture','bokehApertureVal',v=>World.bokehPass&&(World.bokehPass.uniforms.aperture.value=v)],
      ['exposure','exposureVal',v=>World.renderer.toneMappingExposure=v],
      ['renderScale','renderScaleVal',v=>{
        World.renderer.setPixelRatio(Math.min(window.devicePixelRatio,1)*v);
        World.renderer.setSize(innerWidth,innerHeight);
        World.composer?.setSize(innerWidth,innerHeight);
      }]
    ];
    pairs.forEach(([id,val,fn])=>{
      const input=document.getElementById(id), span=document.getElementById(val);
      input.addEventListener('input',()=>{span.textContent=input.value; fn(parseFloat(input.value));});
    });
    ['toggleBloom','toggleDOF','toggleVignette'].forEach(id=>{
      document.getElementById(id).addEventListener('change',()=>this.applyEffects());
    });
    document.getElementById('resumeBtn').addEventListener('click',()=>Pause.resume());
    document.getElementById('restartBtn').addEventListener('click',()=>location.reload());
    document.getElementById('quitBtn').addEventListener('click',()=>location.reload());
  },
  applyEffects(){
    GameState.effects.bloom=document.getElementById('toggleBloom').checked;
    GameState.effects.dof=document.getElementById('toggleDOF').checked;
    GameState.effects.vignette=document.getElementById('toggleVignette').checked;
    if(World.bloomPass) World.bloomPass.enabled=GameState.effects.bloom;
    if(World.bokehPass) World.bokehPass.enabled=GameState.effects.dof;
    if(World.vignettePass) World.vignettePass.uniforms.enabled.value=GameState.effects.vignette?1:0;
  }
};
const Pause={
  show(){
    GameState.paused=true;
    document.getElementById('pauseMenu').classList.remove('hidden');
    if(document.pointerLockElement) document.exitPointerLock();
  },
  resume(){
    GameState.paused=false;
    document.getElementById('pauseMenu').classList.add('hidden');
  },
  toggle(){GameState.paused?this.resume():this.show();}
};

/* ----------------------------- Spawn Helpers ------------------------------ */
function spawnPlayer(){
  const cfg=GameState.difficulty||DIFFICULTIES.tutorial;
  const player=new Player(cfg);
  player.pos.set(0,0,8);
  ECS.add(player);
  PlayerSystem.lastPos.copy(player.pos);
}
function spawnCitizens(){
  const cfg=GameState.difficulty||DIFFICULTIES.tutorial;
  for(let i=0;i<cfg.citizens;i++){
    const c=EntityFactory.createCitizen();
    if(i<cfg.initialInfected){
      c.state='infected'; c.timer=0; c.nextStateTime=rand(11,19); EntityFactory.updateCitizenMaterial(c);
    }
    ECS.add(c);
  }
}
function startSimulationWithDifficulty(diff){
  if(GameState.started) return;
  GameState.started=true;
  spawnPlayer(); spawnCitizens(); Tutorial.init();
  Events.emit('log',{text:`Difficulty: ${diff.label} initialized.`,cls:'good'});
  Events.emit('story',{html:`<b>${diff.tutorial?'Tutorial Mode':'Simulation Online'}</b><br><br>${diff.tutorial
     ? 'Follow the tutorial tasks to learn controls.'
     : 'Drive R(t) below 1.0 and raise immunity. Good luck.'}`});
  document.getElementById('missionText').textContent = diff.tutorial? 'Complete tutorial tasks' : 'Stabilize outbreak';
}

/* ------------------------------ Radar ------------------------------------- */
(function setupRadar(){
  const r=document.getElementById('radar');
  const c=document.createElement('canvas'); c.width=200; c.height=200; r.appendChild(c);
  const ctx=c.getContext('2d');
  function draw(){
    ctx.clearRect(0,0,200,200);
    ctx.save(); ctx.translate(100,100);
    ctx.strokeStyle='#25576a'; ctx.lineWidth=1;
    [92,60,30].forEach(rad=>{ctx.beginPath();ctx.arc(0,0,rad,0,Math.PI*2);ctx.stroke();});
    if(ECS.player){
      const scale=1/2.2;
      ECS.citizens.forEach(ci=>{
        const dx=(ci.pos.x-ECS.player.pos.x)*scale;
        const dz=(ci.pos.z-ECS.player.pos.z)*scale;
        if(Math.abs(dx)<95 && Math.abs(dz)<95){
          ctx.fillStyle = ci.state==='infected' ? '#ff3d55' : (ci.state==='immune' ? '#4dffd7' : '#366d86');
          ctx.fillRect(dx-2,dz-2,4,4);
        }
      });
    }
    ctx.restore();
    requestAnimationFrame(draw);
  }
  draw();
})();

/* ------------------------------ Main Loop --------------------------------- */
let running=true;
function animate(){
  if(!running) return;
  requestAnimationFrame(animate);
  const dtRaw=World.clock.getDelta();
  const dt=Math.min(dtRaw,0.1);
  if(GameState.started && !GameState.paused){
    AI.sim(dt);
    AI.spread(dt);
    PlayerSystem.update(dt);
    PickupSystem.update(dt);
    BarrierSystem.update(dt);
    InfectionSystem.update(dt);
    ParticleSystem.update(dt);
    CollisionSystem.update(dt);
    Tutorial.evaluate();
  }
  const t=performance.now()/1000;
  if(World.sun){
    World.sun.position.x=Math.sin(t*0.06)*55;
    World.sun.position.z=Math.cos(t*0.06)*55;
  }
  if(World.sky) World.sky.material.uniforms.t.value=t;
  World.render();
  Events.emit('tick',{dt});
}

/* ------------------------------ Boot -------------------------------------- */
function boot(){
  const canvas=document.getElementById('game');
  World.init(canvas);
  Input.init(canvas);
  UI.init();
  DifficultyMenu.init();
  Settings.init();
  animate();
  setTimeout(()=>Events.emit('log',{text:'Core systems ready. Select a difficulty.',cls:'warn'}),550);
  setTimeout(()=>document.getElementById('loadHint').textContent='Generating city & outbreak model...',420);
  setTimeout(()=>document.getElementById('loadHint').textContent='Ready. Choose a difficulty to start.',1150);
  // Intro
  Events.emit('story',{html:`<b>Pandemic Response Console</b><br><br>
Select a difficulty to begin. Tutorial mode recommended for firstâ€‘time operatives.<br><br>
Higher modes: More initial infections & faster spread momentum.`});
}
boot();

/* ------------------------------ Expose Debug ------------------------------ */
window.__VECTOR_CITY__={ECS,GameState,DIFFICULTIES,World,PlayerSystem};

/* ---------------------------------------------------------------------------
   END
--------------------------------------------------------------------------- */
</script>
</body>
</html>
